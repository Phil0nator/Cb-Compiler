/**
 * malloc provides higher level memory management.
 */
#ifndef __MALLOC
#define __MALLOC 1
#include "sys/mman.cb"
#include "algorithm/algorithm.k"
#include "assert/assert.k"


#define MALLOC_PAGESIZE 4096
#define MALLOC_PAGESIZE_ADJUSTED (MALLOC_PAGESIZE-sizeof(mblock))
#define MALLOC_USERPTR(localptr) ((localptr)+sizeof(mblock))
#define MALLOC_LOCALPTR(userptr) ((userptr)-sizeof(mblock))
#define MALLOC_MAXCACHE (MALLOC_PAGESIZE * 128)


struct mblock{

    size_t size;
    mblock* next;
    mblock* prev;

};

mblock* free_head = nullptr;
size_t cached_size = NULL;


void remove_block(mblock* block){
    assert(block != nullptr);
    cached_size-=block->size;

    if (block == free_head){
        free_head = block->next;
    }

    if(block->next != nullptr){
        block->next->prev = block->prev;
    }
    if(block->prev != nullptr){
        block->prev->next = block->next;
    }
    block->prev=nullptr;
    block->next=nullptr;

}

bool scan_merge(mblock* b){

    if(cached_size > MALLOC_MAXCACHE){
        cached_size-=b->size;
        destroy_ptr(b);
        return false;
    }

    for each_link(mblock, block, next, free_head) {
        if( (b + b->size + mblock) == block){
            // b->size += block->size + mblock;
            // printstate();

            // printf("Newsize: %u\n Newstate:", b->size);
            // remove_block(block);
            // simple_add(b);
            // printstate();
            // return false;
        }

    }

    return true;
}

void simple_add(mblock* block){
    if(free_head == nullptr){
        free_head = block;
        return;
    }


    free_head->prev = block;
    block->next = free_head;
    free_head = block;

}

void add_block(mblock* block){
    
    assert(block != nullptr);


    cached_size += block->size;
    if(free_head == nullptr){
        free_head = block;
        return;
    }

    simple_add(block);
}

mblock* scan_existing(size_t request){

    if(free_head == nullptr){
        return nullptr;
    }
    for each_link(mblock,block,next,free_head){
        if(block->size >= request){
            remove_block(block);
            split_block(block, request);
            return block;
        }

    }

    return nullptr;

}

void printstate(){
    printf("=======================\n");
    if(free_head == nullptr){
        printf("EMPTY\n");
    }else{
        for each_link(mblock, block, next, free_head){
            printf("BLOCK: %i @ %x\n", block->size, block);
        }
    }




    printf("=======================\n");
}


inline mblock* create_ptr(size_t size){
    return qmmap(size);
}
inline void destroy_ptr(mblock* ptr){
    return munmap(ptr, ptr->size+sizeof(mblock));
}

void split_block(mblock* block, size_t destsize){

    assert(destsize <= block->size);

    if(block->size == destsize){
        return;
    }

    size_t othersize = block->size - destsize;
    if(othersize < sizeof(mblock)){
        return;
    }
    mblock* newblock = ($mblock* MALLOC_USERPTR(block + destsize));
    newblock->size = othersize - sizeof(mblock);
    newblock->next = nullptr;
    newblock->prev = nullptr;

    block->size = destsize ;

    add_block(newblock);

}

global void free(void* usrptr){

    mblock* block = MALLOC_LOCALPTR(usrptr);
    add_block(block);

}


global void* malloc(size_t size){

    mblock* block = scan_existing(size);
    if(block != nullptr){
        return MALLOC_USERPTR(block);
    }
    size_t newsize = size < MALLOC_PAGESIZE_ADJUSTED ? MALLOC_PAGESIZE : size;
    block = create_ptr(newsize);
    block->size = newsize;
    block->prev = nullptr;
    block->next = nullptr;
    split_block(block, size);
    return MALLOC_USERPTR(block);
}


global void* realloc(void* addr, size_t newsize){
    
    if(addr == nullptr){
        return malloc(newsize);
    }
    mblock* block = MALLOC_LOCALPTR(addr);
    size_t oldsize = block->size;
    if(oldsize == newsize){
        return addr;
    }
    add_block(block);
    
    void* out = malloc(newsize);
    
    avx_memcpy(out, addr, oldsize);
    memset(out+oldsize, 0, newsize-oldsize);
    return out;

}





#endif