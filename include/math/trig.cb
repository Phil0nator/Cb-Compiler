#ifndef __MATH
#error "trig.cb should only be included through math/math.cb."
#endif
#ifdef __TRIG
#error "trig.cb should only be included through math/math.cb"
#endif
#define __TRIG

#include "limits.k"

#define __TAYLOR_3F     (3*2)
#define __TAYLOR_5F     (__TAYLOR_3F*5*4)
#define __TAYLOR_7F     (__TAYLOR_5F*7*6)
#define __TAYLOR_9F     (__TAYLOR_7F*9*8)

#define __TAYLOR_P3(x) (x*x*x)
#define __TAYLOR_P5(x) (__TAYLOR_P3(x)*x*x)
#define __TAYLOR_P7(x) (__TAYLOR_P5(x)*x*x)
#define __TAYLOR_P9(x) (__TAYLOR_P7(x)*x*x)





/**
 * A degree nine taylor approximation of the sin function
 */
double taylor_sin(double x){

    return x - (__TAYLOR_P3(x)/__TAYLOR_3F) + (__TAYLOR_P5(x)/__TAYLOR_5F) - (__TAYLOR_P7(x)/__TAYLOR_7F) +  (__TAYLOR_P9(x)/__TAYLOR_9F);

}

/**
 * Taylor series approxomated sin function (degree 9 by default)
 * @param x sin input
 * @returns sin(x)
 */
global double sin(double x){
    if (x != 0){       
        return  taylor_sin(M_PI - fmod(x, 2*M_PI));
    }
    return 0;

}

/**
 * Taylor series cosine
 * @see sin
 * @param x input
 * @returns cos(x)
 */
global double cos(double x){

    if(x != 0){
        return sin(x+M_PI_2);
    }
    return 1;

}


/**
 * Taylor series tan
 * @see sin, cos
 * @param x input
 * @returns tan(x)
 * @warning (Will return Inf, -Inf, or QNaN for undefined values)
 */
global double tan(double x){
    if(x != 0){
        return sin(x) / cos (x);
    }
    return 0; 
}

/**
 * Taylor series cot
 * @see tan
 * @param x input
 * @returns cot(x)
 * @warning (Will return Inf, -Inf, or QNaN for undefined values)
 */
global double cot(double x){
    if( x != 0 ){
        return 1.0 / tan(x);
    }
    return QNAN;
}

/**
 * Taylor series sec
 * @see cos
 * @param x input
 * @returns cot(x)
 * @warning (Will return Inf, -Inf, or QNaN for undefined values)
 */
global double sec(double x){
    if( x!= 0){
        return 1.0 / cos(x);
    }
    return 1;
}

/**
 * Taylor series csc
 * @see sin
 * @param x input
 * @returns cot(x)
 * @warning (Will return Inf, -Inf, or QNaN for undefined values)
 */
global double csc(double x){
    if (x!=0){
        return 1.0 / sin(x);
    }
    return QNAN;
}

#define __TAYLOR_ASIN1      0.5
#define __TAYLOR_ASIN2      0.375
#define __TAYLOR_ASIN3      0.3125
#define __TAYLOR_ASIN4      0.2734375

#define __TAYLOR_ASINT1     (__TAYLOR_ASIN1*(__TAYLOR_P3(x)/3.0))
#define __TAYLOR_ASINT2     (__TAYLOR_ASIN2*(__TAYLOR_P5(x)/5.0))
#define __TAYLOR_ASINT3     (__TAYLOR_ASIN3*(__TAYLOR_P7(x)/7.0))
#define __TAYLOR_ASINT4     (__TAYLOR_ASIN4*(__TAYLOR_P9(x)/9.0))

global double taylor_asin(double x){
    return x + __TAYLOR_ASINT1 + __TAYLOR_ASINT2 + __TAYLOR_ASINT3 + __TAYLOR_ASINT4;
}


/**
 * Taylor series arcsin (sin^-1)
 * @param x input
 * @returns sin^-1(x)
 * @warning (Will return Inf, -Inf, or QNaN for undefined values)
 */
global double asin(double x){
    if(x < -1 || x > 1){
        return QNAN;
    }
    return taylor_asin(x);
}

/**
 * Taylor series arccos (cos^-1)
 * @param x input
 * @returns cos^-1(x)
 * @warning (Will return Inf, -Inf, or QNaN for undefined values)
 */
global double acos(double x){
    if(x < -1 || x > 1){
        return QNAN;
    }
    return M_PI_2 - taylor_asin(x);
}

#define __TAYLOR_ATAN3(x)       (1.0/(3.0*(__TAYLOR_P3(x))))
#define __TAYLOR_ATAN5(x)       (1.0/(5.0*(__TAYLOR_P5(x))))
#define __TAYLOR_ATAN7(x)       (1.0/(7.0*(__TAYLOR_P7(x))))
#define __TAYLOR_ATAN9(x)       (1.0/(9.0*(__TAYLOR_P9(x))))

#define __VANILLA_PS(x)         x - (__TAYLOR_P3(x)/3.0) + (__TAYLOR_P5(x)/5.0) - (__TAYLOR_P7(x)/7.0) + (__TAYLOR_P9(x)/9.0)

/**
 * Taylor series arctan (tan^-1)
 * @param x input
 * @returns tan^-1 (x)
 * @warning (Will return Inf, -Inf, or QNaN for undefined values)
 */
global double atan(double x){
    if(x == -1){
        return (-M_PI_4);
    }else if (x == 1){
        return M_PI_4;
    }else if (x == 0){
        return 0;
    }else if ( (x <= 1) && (x >= -1)){
        return __VANILLA_PS(x);
    }else if (x < -1){
        return 0-M_PI_2-(1/x)+__TAYLOR_ATAN3(x)-__TAYLOR_ATAN5(x);
    }else if (x > 1){
        return M_PI_2-(1/x)+__TAYLOR_ATAN3(x)-__TAYLOR_ATAN5(x);
    }
    return QNAN;
}

/**
 * Taylor series arctan of an x and y coordinate.
 * @param x x coord
 * @param y y coord
 * @returns arctan( y/x )
 * @warning (Will return Inf, -Inf, or QNaN for undefined values)
 */
#define atan2(x, y)         atan(y/x);