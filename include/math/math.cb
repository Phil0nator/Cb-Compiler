/*
  * <math.k> includes some commonly used high level math functions and constants
*/

#ifndef __MATH
#define __MATH 1



#define MAXUINT -1

#include "constants.cb" /* useful math constants */
#include "primitive.cb" /* Asm macros for primitives */

/**
 * Square root.
 * @param a input
 * @returns square root of a
 */
inline double sqrt(double a){
  __MATHBASE_SQRT;
}
/**
 * Square root.
 * @param a input
 * @returns square root of a
 */
inline double sqrt(long a){

  __MATHBASE_CVTSI2SD;
  __MATHBASE_SQRT;

}
/**
 * Square root.
 * @param a input
 * @returns square root of a
 */
inline long sqrt(long a){

  __MATHBASE_CVTSI2SD;
  __MATHBASE_SQRT;
  __MATHBASE_TRUNC;

}


/**
 * Exponentiation.
 * @param base base of exponent
 * @param exp the exponent
 * @returns base^exp
 */
global long pow(long base, long exp){

  __asm{"
  
  mov rax, rdi
  dec rsi
  jz _int_pow_pintint_end
  _int_pow_pintint_flp:
  mul rdi
  dec rsi
  jnz _int_pow_pintint_flp
  _int_pow_pintint_end:
  "}


}

/**
 * Exponentiation.
 * @param base base of exponent
 * @param exp the exponent
 * @returns base^exp
 */
global double pow(long base, long exp){

  pow(base, exp);
  __MATHBASE_CVTSI2SD;

}

/**
 * Exponentiation.
 * @param base base of exponent
 * @param exp the exponent
 * @returns base^exp
 */
global double pow(double base, long exp){

  __asm{"
  
    
    dec rdi
    _double_pow_pdoubleint_flp:
    mulsd xmm0, xmm0
    dec rdi
    jnz _int_pow_pintint_flp
  
  
  "}

}


/**
 * Round a floating point double to an integer.
 * @param x value to round
 * @returns closest integer to x
 */
inline long round(double x){
  __MATHBASE_ROUND;
}

/**
 * Round a floating point double upwards.
 * @param x value to ceil
 * @returns integer higher than x
 */
global long ceil(double x){
  return 0-floor(0-x);
}

/**
 * Truncate a floating point double.
 * @param x value to truncate
 * @returns x without a decimal point
 */
inline long trunc(double x){
  __MATHBASE_TRUNC;
}

/**
 * Round a floating point double downwards.
 * @param x number to floor
 * @returns integer below x
 */
global long floor(double x){
  return round(x-0.5);
}

/**
 * Absolute value.
 * @param x value
 * @returns |x|
 */
global long abs(long x){

  __asm{"
  
  mov rax, rdi
  sar rdi, 63
  xor rax, rdi
  sub rax, rdi
  
  "}

}


/**
 * Absolute value.
 * @param x value
 * @returns |x|
 */
global double abs(double x){

  __asm{"



  movq rax, xmm0
  shl rax, 1
  shr rax, 1
  movq xmm0, rax 


  "}

}


/**
 * Base 10 integer logarithm.
 * @param x value
 * @returns log(x)
 */
global long log(long x){
  
  return log2(x) / M_LOG2_10;

}
/**
 * Arbitrary base integer logarithm.
 * @param base base
 * @param n log
 * @returns log base base of n
 */
global long log(long base, long n){
  
  return log2(n) / log2(base);
  
}
/**
 * Integer log base 2.
 * @param n value
 * @returns log2(n)
 */
global long log2(long n){
  __asm{"
  
  xor rax, rax
  %L_long_lop2_plong_flp:
  sar rdi, 1
  inc rax
  test rdi, rdi
  jnz %L_long_lop2_plong_flp
  dec rax
  "}
}

/**
 * Modulo of two floating point values.
 * @param x inp a
 * @param n inp b
 * @returns x % n
 */
global double fmod(double x, double n){
  return (0-n)*(floor(x/n))+x;
}



/**
 * Take the modulus and quotient of a single division operation.
 * (This is useful because integer division is the most expensive integer operation)
 * @param dividend dividend
 * @param divisor divisor
 * @param modulus destination for value of modulus
 * @returns dividend / divisor, @modulus = dividend % divisor
 */
global long divmod(long dividend, long divisor, long* modulus ){

  __asm{"
  mov rbx, rdx
  xor rdx, rdx
  mov rax, rdi
  div rsi
  mov [rbx], rdx
  "}

}


/**
 * 
 */
global long divmods(long dividend, long divisor, long* modulus){
  __asm{"
  mov rbx, rdx
  xor rdx, rdx
  mov rax, rdi
  idiv rsi
  mov [rbx], rdx
  "}
}


/**
 * More complex math functions:
 */

#include "trig.cb"

#endif